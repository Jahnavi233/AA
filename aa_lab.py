# -*- coding: utf-8 -*-
"""AA Lab.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lM1LsoprQ0tQ1bOd7IjUTeNl8_0rmcL7

##**BINARY SEARCH**
"""

def binary_search(arr, target):
    low = 0
    high = len(arr) - 1

    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1

    return -1

# Example usage
arr = [1, 2, 3, 4, 5]
target = 4
result = binary_search(arr, target)
print(f"Binary Search: Element {target} found at index {result}")

"""##**BUBBLE SORT**"""

def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr

# Example usage
arr = [64, 34, 25, 12, 22, 11, 90]
sorted_arr = bubble_sort(arr)
print(f"Bubble Sort: Sorted array is {sorted_arr}")

"""##**QUICK SORT**"""

def quick_sort(arr, low, high):
    if low < high:
        pi = partition(arr, low, high)
        quick_sort(arr, low, pi - 1)  # Recursively sort the left subarray
        quick_sort(arr, pi + 1, high)  # Recursively sort the right subarray

def partition(arr, low, high):
    pivot = arr[high]  # Pivot element
    i = low - 1        # Index of smaller element
    for j in range(low, high):
        if arr[j] < pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]  # Swap if element is smaller than pivot
    arr[i + 1], arr[high] = arr[high], arr[i + 1]  # Swap pivot to correct position
    return i + 1

# Example usage
arr = [10, 7, 8, 9, 1, 5]
quick_sort(arr, 0, len(arr) - 1)
print("Sorted array is:", arr)

"""##**MERGE SORT**"""

def merge_sort(arr):
    if len(arr) > 1:
        mid = len(arr) // 2
        left_half = arr[:mid]
        right_half = arr[mid:]

        merge_sort(left_half)
        merge_sort(right_half)

        i = j = k = 0

        while i < len(left_half) and j < len(right_half):
            if left_half[i] < right_half[j]:
                arr[k] = left_half[i]
                i += 1
            else:
                arr[k] = right_half[j]
                j += 1
            k += 1

        while i < len(left_half):
            arr[k] = left_half[i]
            i += 1
            k += 1

        while j < len(right_half):
            arr[k] = right_half[j]
            j += 1
            k += 1

# Example usage
arr = [12, 11, 13, 5, 6, 7]
merge_sort(arr)
print("Sorted array is:", arr)

"""##**INSERTION SORT**"""

def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key

# Example usage
arr = [12, 11, 13, 5, 6]
insertion_sort(arr)
print("Sorted array is:", arr)

"""##**SELECTION SORT**"""

def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        min_index = i
        for j in range(i+1, n):
            if arr[j] < arr[min_index]:
                min_index = j
        arr[i], arr[min_index] = arr[min_index], arr[i]
    return arr

# Example usage
arr = [64, 25, 12, 22, 11]
sorted_arr = selection_sort(arr)
print(f"Selection Sort: {sorted_arr}")

"""##**DFS RECURSIVE**"""

def dfs_recursive(graph, node, visited=None):
    if visited is None:
        visited = set()

    # Mark the current node as visited
    visited.add(node)
    print(node, end=" ")

    # Recur for all adjacent vertices
    for neighbor in graph[node]:
        if neighbor not in visited:
            dfs_recursive(graph, neighbor, visited)

# Example usage:

graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': [],
    'F': []
}

print("DFS Traversal (Recursive): ", end="")
dfs_recursive(graph, 'A')

"""##**DFS ITERATIVE**"""

def dfs_iterative(graph, start_node):
    visited = set()  # To keep track of visited nodes
    stack = [start_node]  # Stack to manage the nodes to visit

    while stack:
        node = stack.pop()  # Pop a node from the stack
        if node not in visited:
            print(node, end=" ")
            visited.add(node)

            # Push all unvisited adjacent nodes to the stack
            for neighbor in reversed(graph[node]):
                if neighbor not in visited:
                    stack.append(neighbor)

# Example usage:

graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': [],
    'F': []
}

print("DFS Traversal (Iterative): ", end="")
dfs_iterative(graph, 'A')

"""##**BFS**"""

from collections import deque

def bfs(graph, start):
    visited = set()  # Set to keep track of visited nodes
    queue = deque([start])  # Initialize the queue with the start node

    while queue:
        node = queue.popleft()  # Dequeue a node
        if node not in visited:
            print(node, end=" ")  # Process the node (e.g., print it)
            visited.add(node)  # Mark the node as visited

            # Enqueue all unvisited neighbors
            for neighbor in graph[node]:
                if neighbor not in visited:
                    queue.append(neighbor)

# Example usage
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

print("BFS traversal starting from node 'A':")
bfs(graph, 'A')

"""##**DJIKSTRAS**

"""

import heapq

def dijkstra(graph, start):
    # Initialize distances and priority queue
    distances = {node: float('infinity') for node in graph}
    distances[start] = 0
    priority_queue = [(0, start)]

    while priority_queue:
        # Get the node with the smallest distance
        current_distance, current_node = heapq.heappop(priority_queue)

        # Skip processing if we've already found a shorter path
        if current_distance > distances[current_node]:
            continue

        # Examine neighbors
        for neighbor, weight in graph[current_node].items():
            distance = current_distance + weight

            # Only consider paths that improve the distance to the neighbor
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(priority_queue, (distance, neighbor))

    return distances

graph = {
    'A': {'B': 1, 'C': 4},
    'B': {'A': 1, 'C': 2, 'D': 5},
    'C': {'A': 4, 'B': 2, 'D': 1},
    'D': {'B': 5, 'C': 1}
}
start_node = 'A'
shortest_distances = dijkstra(graph, start_node)
print(f"Shortest distances from node {start_node}: {shortest_distances}")

"""##**PRIMS**"""

import heapq

def prim(graph, start):
    # Initialize the MST and the priority queue
    mst = []
    visited = set([start])
    edges = [(cost, start, to) for to, cost in graph[start].items()]
    heapq.heapify(edges)

    while edges:
        cost, frm, to = heapq.heappop(edges)

        # If the node has already been visited, skip it
        if to in visited:
            continue

        # Add the edge to the MST
        mst.append((frm, to, cost))
        visited.add(to)

        # Add all edges from the newly visited node to the priority queue
        for to_next, cost in graph[to].items():
            if to_next not in visited:
                heapq.heappush(edges, (cost, to, to_next))

    return mst
graph = {
    'A': {'B': 1, 'C': 3},
    'B': {'A': 1, 'C': 3, 'D': 6},
    'C': {'A': 3, 'B': 3, 'D': 4, 'E': 2},
    'D': {'B': 6, 'C': 4, 'E': 5},
    'E': {'C': 2, 'D': 5}
}
mst = prim(graph, 'A')
print(mst)

"""##**KRUSHKALS**"""

class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n

    def find(self, node):
        if self.parent[node] != node:
            self.parent[node] = self.find(self.parent[node])
        return self.parent[node]

    def union(self, u, v):
        root_u = self.find(u)
        root_v = self.find(v)

        if root_u != root_v:
            # Union by rank
            if self.rank[root_u] > self.rank[root_v]:
                self.parent[root_v] = root_u
            elif self.rank[root_u] < self.rank[root_v]:
                self.parent[root_u] = root_v
            else:
                self.parent[root_v] = root_u
                self.rank[root_u] += 1

def kruskal(nodes, edges):
    # Sort edges by weight
    edges.sort(key=lambda x: x[2])
    uf = UnionFind(nodes)
    mst = []

    for u, v, weight in edges:
        # Check if the current edge forms a cycle
        if uf.find(u) != uf.find(v):
            uf.union(u, v)
            mst.append((u, v, weight))

    return mst
nodes = 5
edges = [
    (0, 1, 1),
    (0, 2, 3),
    (1, 2, 3),
    (1, 3, 6),
    (2, 3, 4),
    (2, 4, 2),
    (3, 4, 5)
]
mst = kruskal(nodes, edges)
print(mst)

"""##**Ford-Fulkerson algorithm**"""

class Graph:
    def __init__(self, graph):
        self.graph = graph  # Residual graph
        self.ROW = len(graph)

    def dfs(self, source, sink, parent):
        visited = [False] * self.ROW
        stack = [source]
        visited[source] = True

        while stack:
            u = stack.pop()

            for v, capacity in enumerate(self.graph[u]):
                if not visited[v] and capacity > 0:  # Check if there's available capacity
                    stack.append(v)
                    visited[v] = True
                    parent[v] = u
                    if v == sink:
                        return True
        return False

    def ford_fulkerson(self, source, sink):
        parent = [-1] * self.ROW
        max_flow = 0

        while self.dfs(source, sink, parent):
            # Find the maximum flow through the path found by DFS
            path_flow = float('Inf')
            s = sink
            while s != source:
                path_flow = min(path_flow, self.graph[parent[s]][s])
                s = parent[s]

            # Update residual capacities of the edges and reverse edges along the path
            v = sink
            while v != source:
                u = parent[v]
                self.graph[u][v] -= path_flow
                self.graph[v][u] += path_flow
                v = parent[v]

            max_flow += path_flow

        return max_flow
graph = [
    [0, 16, 13, 0, 0, 0],
    [0, 0, 10, 12, 0, 0],
    [0, 4, 0, 0, 14, 0],
    [0, 0, 9, 0, 0, 20],
    [0, 0, 0, 7, 0, 4],
    [0, 0, 0, 0, 0, 0]
]
g = Graph(graph)
source = 0
sink = 5
max_flow = g.ford_fulkerson(source, sink)
print(f"Maximum Flow: {max_flow}")

class Graph:
    def __init__(self, graph):
        self.graph = graph  # Residual graph
        self.ROW = len(graph)

    def dfs(self, source, sink, parent):
        visited = [False] * self.ROW
        stack = [source]
        visited[source] = True

        while stack:
            u = stack.pop()

            for v, capacity in enumerate(self.graph[u]):
                if not visited[v] and capacity > 0:  # Check if there's available capacity
                    stack.append(v)
                    visited[v] = True
                    parent[v] = u
                    if v == sink:
                        return True
        return False

    def ford_fulkerson(self, source, sink):
        parent = [-1] * self.ROW
        max_flow = 0
        iteration = 1

        while self.dfs(source, sink, parent):
            # Find the maximum flow through the path found by DFS
            path_flow = float('Inf')
            s = sink
            path = []
            while s != source:
                path_flow = min(path_flow, self.graph[parent[s]][s])
                path.append(s)
                s = parent[s]
            path.append(source)
            path = path[::-1]  # reverse to get the path from source to sink

            print(f"Iteration {iteration}: Augmenting path found - {path} with flow {path_flow}")

            # Update residual capacities of the edges and reverse edges along the path
            v = sink
            while v != source:
                u = parent[v]
                self.graph[u][v] -= path_flow
                self.graph[v][u] += path_flow
                v = parent[v]

            max_flow += path_flow
            print(f"Updated Residual Graph after iteration {iteration}:")
            for row in self.graph:
                print(row)
            print("\n")
            iteration += 1

        print(f"Maximum Flow: {max_flow}")
        return max_flow
graph = [
    [0, 16, 13, 0, 0, 0],
    [0, 0, 10, 12, 0, 0],
    [0, 4, 0, 0, 14, 0],
    [0, 0, 9, 0, 0, 20],
    [0, 0, 0, 7, 0, 4],
    [0, 0, 0, 0, 0, 0]
]

g = Graph(graph)
source = 0
sink = 5
g.ford_fulkerson(source, sink)

"""##**EDMONDS-KARP**"""

from collections import deque

class Graph:
    def __init__(self, graph):
        self.graph = graph  # Residual graph
        self.ROW = len(graph)

    def bfs(self, source, sink, parent):
        visited = [False] * self.ROW
        queue = deque([source])
        visited[source] = True

        while queue:
            u = queue.popleft()

            for v, capacity in enumerate(self.graph[u]):
                if not visited[v] and capacity > 0:  # If there's available capacity and v is not visited
                    queue.append(v)
                    visited[v] = True
                    parent[v] = u
                    if v == sink:
                        return True
        return False

    def edmonds_karp(self, source, sink):
        parent = [-1] * self.ROW
        max_flow = 0
        iteration = 1

        while self.bfs(source, sink, parent):
            # Find the maximum flow through the path found by BFS
            path_flow = float('Inf')
            s = sink
            path = []
            while s != source:
                path_flow = min(path_flow, self.graph[parent[s]][s])
                path.append(s)
                s = parent[s]
            path.append(source)
            path = path[::-1]  # reverse to get the path from source to sink

            print(f"Iteration {iteration}: Augmenting path found - {path} with flow {path_flow}")

            # Update residual capacities of the edges and reverse edges along the path
            v = sink
            while v != source:
                u = parent[v]
                self.graph[u][v] -= path_flow
                self.graph[v][u] += path_flow
                v = parent[v]

            max_flow += path_flow
            print(f"Updated Residual Graph after iteration {iteration}:")
            for row in self.graph:
                print(row)
            print("\n")
            iteration += 1

        print(f"Maximum Flow: {max_flow}")
        return max_flow
graph = [
    [0, 16, 13, 0, 0, 0],
    [0, 0, 10, 12, 0, 0],
    [0, 4, 0, 0, 14, 0],
    [0, 0, 9, 0, 0, 20],
    [0, 0, 0, 7, 0, 4],
    [0, 0, 0, 0, 0, 0]
]

g = Graph(graph)
source = 0
sink = 5
g.edmonds_karp(source, sink)

"""##**STRASSENS**"""

import numpy as np

def add_matrix(A, B):
    return [[A[i][j] + B[i][j] for j in range(len(A))] for i in range(len(A))]

def subtract_matrix(A, B):
    return [[A[i][j] - B[i][j] for j in range(len(A))] for i in range(len(A))]

def strassen(A, B):
    n = len(A)

    # Base case for recursion
    if n == 1:
        return [[A[0][0] * B[0][0]]]

    # Split matrices into quadrants
    mid = n // 2
    A11 = [row[:mid] for row in A[:mid]]
    A12 = [row[mid:] for row in A[:mid]]
    A21 = [row[:mid] for row in A[mid:]]
    A22 = [row[mid:] for row in A[mid:]]

    B11 = [row[:mid] for row in B[:mid]]
    B12 = [row[mid:] for row in B[:mid]]
    B21 = [row[:mid] for row in B[mid:]]
    B22 = [row[mid:] for row in B[mid:]]

    # Strassen's sub-formulas
    M1 = strassen(add_matrix(A11, A22), add_matrix(B11, B22))
    M2 = strassen(add_matrix(A21, A22), B11)
    M3 = strassen(A11, subtract_matrix(B12, B22))
    M4 = strassen(A22, subtract_matrix(B21, B11))
    M5 = strassen(add_matrix(A11, A12), B22)
    M6 = strassen(subtract_matrix(A21, A11), add_matrix(B11, B12))
    M7 = strassen(subtract_matrix(A12, A22), add_matrix(B21, B22))

    # Calculating the result quadrants
    C11 = add_matrix(subtract_matrix(add_matrix(M1, M4), M5), M7)
    C12 = add_matrix(M3, M5)
    C21 = add_matrix(M2, M4)
    C22 = add_matrix(subtract_matrix(add_matrix(M1, M3), M2), M6)

    # Combining the quadrants into a single matrix
    C = []
    for i in range(mid):
        C.append(C11[i] + C12[i])
    for i in range(mid):
        C.append(C21[i] + C22[i])

    return C
A = [
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12],
    [13, 14, 15, 16]
]

B = [
    [17, 18, 19, 20],
    [21, 22, 23, 24],
    [25, 26, 27, 28],
    [29, 30, 31, 32]
]

result = strassen(A, B)
for row in result:
    print(row)

"""##**Hopcroft-Karp**"""

from collections import deque, defaultdict

class HopcroftKarp:
    def __init__(self, U, V):
        self.U = U  # Set of vertices on the left side
        self.V = V  # Set of vertices on the right side
        self.pair_U = {u: None for u in U}  # Matching pairs for U
        self.pair_V = {v: None for v in V}  # Matching pairs for V
        self.dist = {}  # Distance in the layered graph
        self.graph = defaultdict(list)  # Adjacency list

    def add_edge(self, u, v):
        self.graph[u].append(v)
        self.graph[v].append(u)

    def bfs(self):
        queue = deque()
        for u in self.U:
            if self.pair_U[u] is None:  # Free node in U
                self.dist[u] = 0
                queue.append(u)
            else:
                self.dist[u] = float('inf')
        self.dist[None] = float('inf')

        while queue:
            u = queue.popleft()
            if self.dist[u] < self.dist[None]:
                for v in self.graph[u]:
                    pair_u = self.pair_V[v]
                    if self.dist[pair_u] == float('inf'):
                        self.dist[pair_u] = self.dist[u] + 1
                        queue.append(pair_u)
        return self.dist[None] != float('inf')

    def dfs(self, u):
        if u is not None:
            for v in self.graph[u]:
                pair_u = self.pair_V[v]
                if self.dist[pair_u] == self.dist[u] + 1:
                    if self.dfs(pair_u):
                        self.pair_V[v] = u
                        self.pair_U[u] = v
                        return True
            self.dist[u] = float('inf')
            return False
        return True

    def maximum_matching(self):
        matching = 0
        while self.bfs():
            for u in self.U:
                if self.pair_U[u] is None:
                    if self.dfs(u):
                        matching += 1
        return matching

    def get_matching_pairs(self):
        return [(u, v) for u, v in self.pair_U.items() if v is not None]

U = {1, 2, 3, 4}
V = {5, 6, 7, 8}

graph = HopcroftKarp(U, V)
graph.add_edge(1, 5)
graph.add_edge(1, 6)
graph.add_edge(2, 6)
graph.add_edge(2, 7)
graph.add_edge(3, 7)
graph.add_edge(3, 8)
graph.add_edge(4, 8)

max_matching = graph.maximum_matching()
print(f"Maximum Matching: {max_matching}")
print("Matching Pairs:", graph.get_matching_pairs())

